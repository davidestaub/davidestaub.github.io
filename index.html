<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<title>Davide Staub - Personal Website</title>
  <link rel="stylesheet" href="style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <header>
    <div class="header-content">
      <h1>Davide Staub</h1>
      <!-- Lab icon placed next to your name -->
      <img src="ssml-icon.webp" alt="Scalable Scientific Machine Learning Lab icon" class="lab-icon">
    </div>
  </header>
  <main>
    <section id="bio">
      <h2>Bio</h2>
      <div class="bio-content">
        <!-- Profile photo -->
        <img src="profile.jpg" alt="Profile photo" class="profile-pic">
        <!-- Exoplanet visualisation container placed next to the profile photo.  This
             will render the rotating planet with a satellite orbit in the top
             right corner of the bio section. -->
        <div id="planet-container"></div>
        <p>
          I am Davide Staub, a PhD student at Imperial College London working in the
          <a href="https://scalable-sciml-lab.org/" target="_blank">Scalable Scientific Machine Learning Lab</a>
          under the supervision of Dr.&nbsp;Ben Moseley. My research focuses on
          harnessing machine learning and physics to build differentiable tools for
          reconstructing the three‑dimensional structure of exoplanet atmospheres from
          JWST observations.
          Before starting my PhD, I spent a year at the HomanLab within the
          Psychiatric University Hospital of Zürich, where we combined brain imaging
          and large language models to understand how the brain processes
          narratives.  
          <br>
          <a href="https://www.linkedin.com/in/davide-staub/" target="_blank">LinkedIn</a>
          <br>
          Email: <a href="mailto:dds25@ic.ac.uk">dds25@ic.ac.uk</a>
          <br>
          <!-- CV download link will work once CV_Davide_Staub.pdf is added to the repository -->
          <a href="CV_Davide_Staub.pdf" download>Download my CV</a>
        </p>
      </div>
    </section>

    <!-- Interactive planet‑hunter game section.  Visitors must spot tiny
         exoplanets orbiting distant stars.  Click on an orbiting planet to
         detect it and earn a point.  The planets move continuously, and a
         countdown timer tracks how long you have to hunt.  When time runs
         out, the game ends and you can click again to start a new round. -->
    <section id="orbit-game">
      <h3>Orbit simulator game</h3>
      <p class="game-instructions">Click and drag from the planet to launch a probe.  Adjust your aim and
        speed to try to achieve a stable orbit.  Avoid crashing into the planet or
        escaping into deep space!</p>
      <canvas id="orbit-canvas" width="600" height="300"></canvas>
      <p id="orbit-score">Successful orbits: 0</p>
      <p id="orbit-message"></p>
    </section>
    <section id="teaching">
      <h2 onclick="toggleSection('teaching-content')" class="toggle">Teaching &#9654;</h2>
      <div id="teaching-content" class="content hidden">
        <p>
          <strong>Graduate Teaching Assistant, Imperial College London:</strong> I help deliver the MSc Deep Learning
          course at Imperial College London.  This involves running tutorials, answering students’ questions
          and supporting practical exercises on topics such as neural network fundamentals, optimisation
          and modern architectures.
        </p>
        <p>
          <strong>Lecturer, ETH Zürich – Space Data:</strong> I teach the final third of the
          <a href="https://eaps.ethz.ch/en/studies/master/space-systems.html" target="_blank">Space&nbsp;Data course</a>
          in the Master in Space Systems programme at ETH Zürich.  My block introduces convolutional neural
          networks and U‑Net architectures for denoising images of the Moon’s permanently shadowed regions (PSRs).
          These techniques build on the HORUS framework developed by Ben Moseley and Valentin Bickel, and are key to
          reliable resource mapping and landing‑site planning.  Students learn the basics of deep learning (MLPs,
          CNNs, U‑Nets, etc.) and then apply them to clean up PSR images using real training data.
        </p>
        <figure>
          <img src="psr_crater.png" alt="Image of a lunar crater with a dark permanently shadowed region used in teaching about lunar resource mapping" class="research-img">
          <figcaption>Permanently shadowed regions on the Moon, which require machine‑learning denoising for resource mapping and landing‑site planning.</figcaption>
        </figure>
      </div>
    </section>
    <section id="research">
      <h2 onclick="toggleSection('research-content')" class="toggle">Research &#9654;</h2>
      <div id="research-content" class="content hidden">
        <h3>Current research</h3>
        <p>
          My PhD project aims to develop a single, differentiable pipeline that
          converts all available JWST observations of a hot Jupiter—thermal
          emission spectra, phase curves, eclipses and transmission spectra—into a
          unified three‑dimensional temperature field \(T(\lambda, \phi, p)\). The
          map uses a low‑dimensional spherical‑harmonics basis for horizontal
          structure and smooth vertical modes, and the inversion is regularised
          using physically motivated terms such as energy balance, global
          radiative closure and hydrostatic consistency.  This
          framework treats the atmosphere as a shared state that must
          simultaneously explain observations across multiple viewing geometries.
        </p>

        <!-- Image illustrating current research on hot Jupiter exoplanets -->
        <div class="image-row">
          <figure>
            <img src="current_research.png" alt="Artist’s illustration of a hot Jupiter exoplanet orbiting close to its host star" class="research-img">
            <figcaption>Artist’s impression of a hot Jupiter exoplanet, showing how these giant planets orbit very close to their stars and face extreme atmospheric conditions.</figcaption>
          </figure>
        </div>
        <h3>Previous work</h3>
        <p>
          At the HomanLab in Zürich I explored how our brains follow the flow of stories.  Working with a
          language model, we distilled two simple signals: a <em>drift</em> signal that
          captures the gradual build‑up of meaning as a narrative unfolds, and a
          <em>shift</em> signal that spikes when the story moves to a new event or scene.
          When we compared these signals to high‑resolution fMRI recordings from a
          volunteer listening to crime stories, we found that the burst‑like
          shift signal lit up the brain’s speech and hearing centres, whereas the
          slow drift signal was strongest in the so‑called default‑mode network –
          regions like the angular gyrus, precuneus and posterior cingulate that
          support memory and imagination.  This pattern suggests that auditory
          areas mark event boundaries while broader networks follow the slow evolution
          of context.
        </p>
        <p>
          Below are brain maps showing where each signal explained neural
          responses.  Bright colours indicate regions with stronger effects.
        </p>
        <div class="image-row">
          <figure>
            <img src="shift_map.png" alt="Brain map showing robust shift responses in peri‑Sylvian regions" class="research-img">
            <figcaption>Shift: strong event‑boundary responses in auditory–language cortex.</figcaption>
          </figure>
          <figure>
            <img src="drift_map.png" alt="Brain map highlighting drift responses in higher‑order default‑mode regions" class="research-img">
            <figcaption>Drift: slow accumulation responses in higher‑order default‑mode regions.</figcaption>
          </figure>
        </div>
        <figure>
          <!-- Using the white‑background version of the method diagram to improve contrast on dark pages -->
          <img src="method_diagram_white.png" alt="Diagram summarising the model‑driven approach for deriving drift and shift signals from a language model and mapping them to brain activity" class="research-img">
          <figcaption>Method: converting stories into drift and shift signals via a large language model and mapping them to brain responses.</figcaption>
        </figure>
        <h3>Master’s thesis: Physics‑informed neural networks for seismology</h3>
        <p>
          During my master’s studies at ETH Zürich I investigated Physics‑Informed Neural
          Networks (PINNs) as a way to solve the elastic wave equation, which describes
          how seismic waves propagate through the Earth.  By embedding wave physics
          directly into the network architecture – for example using custom wavelet or
          plane‑wave layers along with encoder and decoder components – I achieved
          solutions that were roughly twice as accurate as standard PINNs.  I also conditioned the networks on the location of the seismic source, allowing them to infer the
          wavefield for countless source locations in a single forward pass and dramatically
          speeding up simulations compared with traditional finite‑difference methods.
        </p>
        <p>
          I presented this work at the 2024 British Seismology Meeting, and it was later summarised in
          <a href="https://academic.oup.com/astrogeo/article-abstract/66/3/3.29/8154308?redirectedFrom=fulltext" target="_blank"><em>Astronomy &amp; Geophysics</em></a>.  The report notes that incorporating wave physics improves
          accuracy and that once trained these networks are much faster than standard numerical solvers.  You can access the full thesis online via its DOI:
          <a href="https://doi.org/10.3929/ethz-b-000668359" target="_blank">10.3929/ethz‑b‑000668359</a>.
        </p>
        <div class="image-row">
          <figure>
            <img src="wavefield.png" alt="Simulation of radial wavefields propagating outward (red and blue rings) generated by physics-informed neural networks" class="research-img">
            <figcaption>Simulated elastic wavefields produced by a physics‑informed neural network.</figcaption>
          </figure>
        </div>
      </div>
    </section>
  </main>
  <footer>
    <p>&copy; 2025 Davide Staub. All rights reserved.</p>
  </footer>
  <script>
    function toggleSection(id) {
      const section = document.getElementById(id);
      section.classList.toggle('hidden');
    }
  </script>

  <!-- Orbit simulator game logic.  Players launch a probe from the planet
       by clicking and dragging.  The probe moves under a simple gravity
       law; achieve a stable orbit to score points.  Collisions or
       escapes end an attempt.  Click again to reset and try a new
       orbit. -->
  <script>
    (function() {
      const canvas = document.getElementById('orbit-canvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const planetRadius = 40;
      const G = 2000; // gravitational constant (scaled)
      let probe = null;
      let path = [];
      let dragging = false;
      let startX, startY;
      let successCount = 0;
      const scoreEl = document.getElementById('orbit-score');
      const messageEl = document.getElementById('orbit-message');
      function resetProbe() {
        probe = null;
        path = [];
        dragging = false;
        messageEl.textContent = '';
      }
      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const dist = Math.hypot(x - centerX, y - centerY);
        // Only allow launching from near the planet surface
        if (dist <= planetRadius + 20) {
          dragging = true;
          startX = x;
          startY = y;
          path = [];
        }
      });
      canvas.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        // draw the arrow while dragging
        render();
        ctx.strokeStyle = '#00bfff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(x, y);
        ctx.stroke();
      });
      canvas.addEventListener('mouseup', (e) => {
        if (!dragging) return;
        dragging = false;
        const rect = canvas.getBoundingClientRect();
        const endX = e.clientX - rect.left;
        const endY = e.clientY - rect.top;
        // initial velocity based on drag vector (scaled)
        const vx = (endX - centerX) * 0.02;
        const vy = (endY - centerY) * 0.02;
        probe = { x: centerX, y: centerY, vx, vy };
        path = [];
        messageEl.textContent = '';
      });
      function update(dt) {
        if (!probe) return;
        const dx = probe.x - centerX;
        const dy = probe.y - centerY;
        const r2 = dx * dx + dy * dy;
        const r = Math.sqrt(r2);
        // gravitational acceleration toward center
        const accel = -G / (r2 * r);
        const ax = accel * dx;
        const ay = accel * dy;
        probe.vx += ax * dt;
        probe.vy += ay * dt;
        probe.x += probe.vx * dt;
        probe.y += probe.vy * dt;
        // record path
        path.push({ x: probe.x, y: probe.y });
        // collision with planet
        if (r <= planetRadius) {
          messageEl.textContent = 'Probe crashed! Click and drag to try again.';
          resetProbe();
        }
        // escape condition (off canvas)
        if (probe.x < 0 || probe.x > width || probe.y < 0 || probe.y > height) {
          messageEl.textContent = 'Probe escaped! Click and drag to try again.';
          resetProbe();
        }
        // success condition: if orbit for more than 8 seconds
        if (path.length * dt > 8 && r > planetRadius + 10 && r < Math.min(width, height) / 2) {
          successCount++;
          scoreEl.textContent = 'Successful orbits: ' + successCount;
          messageEl.textContent = 'Stable orbit achieved! Drag again for a new attempt.';
          resetProbe();
        }
      }
      function render() {
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, width, height);
        // draw planet
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(centerX, centerY, planetRadius, 0, Math.PI * 2);
        ctx.fill();
        // draw probe path
        if (path.length > 1) {
          ctx.strokeStyle = '#00bfff';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(path[0].x, path[0].y);
          for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
          }
          ctx.stroke();
        }
        // draw probe
        if (probe) {
          ctx.fillStyle = '#ffdd55';
          ctx.beginPath();
          ctx.arc(probe.x, probe.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        // draw start arrow? Already drawn in mousemove
      }
      let last = performance.now();
      function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        update(dt);
        render();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    })();
  </script>

  <!-- Load Three.js library for WebGL rendering -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
  <!-- Procedural exoplanet rendering script -->
  <script>
    (function() {
      const container = document.getElementById('planet-container');
      // Only execute if the container exists and Three.js is available
      if (!container || typeof THREE === 'undefined') return;

      let width = container.clientWidth;
      // Use the container's computed height when available; otherwise fall back to a square
      let height = container.clientHeight || width;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(35, width / height, 0.1, 100);
      // Position the camera a bit farther out to ensure the full planet fits in the square container
      camera.position.set(0, 0, 3.4);

      // Lighting setup: use a slightly brighter ambient light and a single key
      // light.  Removing the rim light prevents an outer halo and reduces
      // reflections that can be mistaken for a secondary hull.  Increasing
      // ambient intensity softens the shading for a more cohesive look.
      const ambient = new THREE.AmbientLight(0xffffff, 0.45);
      scene.add(ambient);
      const keyLight = new THREE.DirectionalLight(0xffffff, 0.9);
      keyLight.position.set(3, 2, 4);
      scene.add(keyLight);

      // Helper to convert HSL to hex
      function hslToHex(h, s, l) {
        const a = s * Math.min(l, 1 - l);
        const f = n => {
          const k = (n + h * 12) % 12;
          const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return Math.round(255 * color);
        };
        return '#' + [f(0), f(8), f(4)].map(x => x.toString(16).padStart(2, '0')).join('');
      }

      // Create a procedural texture on a canvas
      function makePlanetTexture(size, baseColor, accentColor) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');

        /*
         * Generate a gas giant texture with convincing swirling clouds and storms.
         * We combine multiple sine waves to create turbulent bands and then
         * sprinkle storms for variety.  A small amount of noise breaks up
         * uniform regions.  The texture is horizontally tiled to simulate
         * planetary rotation.
         */
        const imgData = ctx.createImageData(size, size);
        const data = imgData.data;

        // Convert hex colour strings to RGB arrays
        function hexToRgb(hex) {
          const bigint = parseInt(hex.replace('#', ''), 16);
          return [
            (bigint >> 16) & 255,
            (bigint >> 8) & 255,
            bigint & 255
          ];
        }

        const baseRGB = hexToRgb(baseColor);
        const accentRGB = hexToRgb(accentColor);

        // Frequencies and phases for sine wave patterns
        const freqX = 4 + Math.random() * 4;
        const freqY = 3 + Math.random() * 3;
        const freqDiag = 5 + Math.random() * 3;
        const phaseX = Math.random() * Math.PI * 2;
        const phaseY = Math.random() * Math.PI * 2;
        const phaseDiag = Math.random() * Math.PI * 2;
        const swirlStrength = 2 + Math.random() * 2;

        // Storms
        const stormCount = 2 + Math.floor(Math.random() * 4);
        const storms = [];
        for (let s = 0; s < stormCount; s++) {
          const cx = Math.random() * size;
          const cy = Math.random() * size;
          const radius = size * (0.04 + Math.random() * 0.06);
          storms.push({ cx, cy, radius });
        }

        for (let y = 0; y < size; y++) {
          const ny = y / size;
          for (let x = 0; x < size; x++) {
            const nx = x / size;
            const idx = (y * size + x) * 4;
            // Sine-based turbulent pattern
            const v =
              Math.sin(nx * freqX * Math.PI * 2 + phaseX) +
              Math.sin(ny * freqY * Math.PI * 2 + phaseY) +
              Math.sin((nx + ny) * freqDiag * Math.PI * 2 + phaseDiag);
            // Normalise v to 0..1
            const mix = 0.5 + 0.5 * Math.sin(v * swirlStrength);
            let rCol = baseRGB[0] * (1 - mix) + accentRGB[0] * mix;
            let gCol = baseRGB[1] * (1 - mix) + accentRGB[1] * mix;
            let bCol = baseRGB[2] * (1 - mix) + accentRGB[2] * mix;

            // Limb darkening: fade colours near the edge
            const cxNorm = (nx - 0.5) * 2;
            const cyNorm = (ny - 0.5) * 2;
            const dist = Math.sqrt(cxNorm * cxNorm + cyNorm * cyNorm);
            const limb = 1 - Math.min(1, dist * 0.8);
            rCol *= limb;
            gCol *= limb;
            bCol *= limb;

            // Add storms: brighten towards the centre with accent colours
            for (const st of storms) {
              const dx = x - st.cx;
              const dy = y - st.cy;
              const d2 = dx * dx + dy * dy;
              const rad2 = st.radius * st.radius;
              if (d2 < rad2) {
                const factor = 1 - d2 / rad2;
                rCol = rCol * (1 - factor) + accentRGB[0] * factor;
                gCol = gCol * (1 - factor) + accentRGB[1] * factor;
                bCol = bCol * (1 - factor) + accentRGB[2] * factor;
              }
            }

            // Add moderate random noise for realism
            const noise = (Math.random() - 0.5) * 30;
            rCol += noise;
            gCol += noise;
            bCol += noise;

            // Clamp values
            data[idx] = Math.min(255, Math.max(0, Math.round(rCol)));
            data[idx + 1] = Math.min(255, Math.max(0, Math.round(gCol)));
            data[idx + 2] = Math.min(255, Math.max(0, Math.round(bCol)));
            data[idx + 3] = 255;
          }
        }

        ctx.putImageData(imgData, 0, 0);
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(2, 1);
        tex.needsUpdate = true;
        return tex;
      }

      // Prepare an array of pre‑generated planetary textures.  Each image is a
      // colour‑shifted version of Jupiter's cloud bands.  Choosing randomly
      // from this list on each page load makes the exoplanet look different
      // every time while maintaining realistic structure.
      const textureNames = [
        'exoplanet_var1.jpg',
        'exoplanet_var2.jpg',
        'exoplanet_var3.jpg',
        'exoplanet_var4.jpg',
        'exoplanet_var5.jpg'
      ];
      const textureLoader = new THREE.TextureLoader();
      const chosenName = textureNames[Math.floor(Math.random() * textureNames.length)];
      const baseTexture = textureLoader.load(chosenName);
      // Repeat horizontally and clamp vertically to avoid seams
      baseTexture.wrapS = THREE.RepeatWrapping;
      baseTexture.wrapT = THREE.ClampToEdgeWrapping;
      // Randomise the longitudinal offset so the great red spot appears at
      // different positions on each load
      baseTexture.offset.set(Math.random(), 0);

      // Choose a random tint colour by sampling the entire HSL hue range.  A
      // modest saturation and mid‑level lightness ensure the banded structure
      // remains visible while giving the planet a unique hue.
      const tintHue = Math.random();
      const tintColor = new THREE.Color();
      tintColor.setHSL(tintHue, 0.4 + Math.random() * 0.2, 0.5 + Math.random() * 0.2);

      // Create the planet mesh.  Reduce the radius to 0.5 to further decrease
      // the planet's apparent size.  Apply the chosen texture and tint.
      // Reduce the sphere radius further so the planet comfortably fits
      // within the now smaller container.  A radius of 0.4 provides a
      // roughly three‑fold reduction in apparent size compared with the
      // original version.
      // Create a slightly larger planet mesh.  A radius of 0.45 makes the
      // sphere more prominent while still fitting within the container.  A
      // completely matte material avoids specular highlights.
      // Slightly enlarge the planet radius so it appears bigger relative to
      // the container.  Increasing from 0.45 to 0.5 preserves the
      // three-dimensional feel while keeping the globe fully in view.
      // Increase the planet radius slightly so it appears more prominent within
      // the container.  A radius of 0.7 enhances its size without clipping.
      const planetGeo = new THREE.SphereGeometry(0.8, 96, 96);
      const planetMat = new THREE.MeshStandardMaterial({
        map: baseTexture,
        color: tintColor,
        roughness: 1.0,
        metalness: 0.0
      });
      const planet = new THREE.Mesh(planetGeo, planetMat);
      scene.add(planet);

      // Add a small satellite orbiting the planet.  This sphere will move
      // around the planet on a circular orbit.  Clicking the planet area
      // randomises the orbit radius, tilt and speed.
      const satelliteGeo = new THREE.SphereGeometry(0.07, 24, 24);
      const satelliteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0, metalness: 0.0 });
      const satellite = new THREE.Mesh(satelliteGeo, satelliteMat);
      scene.add(satellite);

      // Orbit parameters
      let orbitRadius = 0.9;
      let orbitSpeed = 0.005;
      let orbitTilt = Math.PI / 8;
      let orbitPhase = 0;

      // Function to randomise the orbit when the user clicks the container
      container.addEventListener('click', () => {
        orbitRadius = 0.6 + Math.random() * 0.4; // range 0.6–1.0
        orbitSpeed = 0.003 + Math.random() * 0.007;
        orbitTilt = Math.random() * Math.PI / 3; // up to 60° tilt
      });

      // Animation loop: rotate the planet and update the satellite's position
      function animate() {
        requestAnimationFrame(animate);
        planet.rotation.y += 0.002;
        planet.rotation.x = Math.sin(Date.now() * 0.0001) * 0.05;
        orbitPhase += orbitSpeed;
        // Compute satellite orbit in tilted plane
        const x = orbitRadius * Math.cos(orbitPhase);
        const z = orbitRadius * Math.sin(orbitPhase);
        const y = orbitRadius * Math.sin(orbitPhase) * Math.sin(orbitTilt);
        // Apply a rotation matrix for tilt
        satellite.position.set(
          x * Math.cos(orbitTilt) - z * Math.sin(orbitTilt),
          y,
          x * Math.sin(orbitTilt) + z * Math.cos(orbitTilt)
        );
        renderer.render(scene, camera);
      }
      animate();

      // Handle resizing of the container
      window.addEventListener('resize', () => {
        width = container.clientWidth;
        height = container.clientHeight || width;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      });
    })();
  </script>
</body>
</html>